From 92a6c434182962704a0cc20bb675655063d2d894 Mon Sep 17 00:00:00 2001
From: Michael Stefaniuc <mstefani@winehq.org>
Date: Mon, 30 Jul 2018 21:18:09 +0200
Subject: [PATCH] kernel32: Use the ARRAY_SIZE() macro

Signed-off-by: Michael Stefaniuc <mstefani@winehq.org>
---
 dlls/kernel32/computername.c |  4 +--
 dlls/kernel32/console.c      |  4 +--
 dlls/kernel32/file.c         |  2 +-
 dlls/kernel32/lcformat.c     | 54 ++++++++++++++++++------------------
 dlls/kernel32/locale.c       | 66 +++++++++++++++++++++-----------------------
 dlls/kernel32/module.c       |  3 +-
 dlls/kernel32/path.c         |  2 +-
 dlls/kernel32/process.c      | 26 ++++++++---------
 dlls/kernel32/profile.c      |  7 ++---
 dlls/kernel32/sync.c         |  8 ++----
 dlls/kernel32/term.c         |  2 +-
 dlls/kernel32/volume.c       | 12 ++++----
 12 files changed, 91 insertions(+), 99 deletions(-)

diff --git a/dlls/kernel32/computername.c b/dlls/kernel32/computername.c
index 1b5f4aa..720d4ba 100644
--- a/dlls/kernel32/computername.c
+++ b/dlls/kernel32/computername.c
@@ -538,9 +538,9 @@ static WCHAR netbios_char ( WCHAR wc )
     static const WCHAR special[] = {'!','@','#','$','%','^','&','\'',')','(','-','_','{','}','~'};
     static const WCHAR deflt = '_';
     unsigned int i;
-    
+
     if ( isalnumW ( wc ) ) return wc;
-    for ( i = 0; i < sizeof (special) / sizeof (WCHAR); i++ )
+    for ( i = 0; i < ARRAY_SIZE( special ); i++ )
         if ( wc == special[i] ) return wc;
     return deflt;
 }
diff --git a/dlls/kernel32/console.c b/dlls/kernel32/console.c
index 51061de..8b98a50 100644
--- a/dlls/kernel32/console.c
+++ b/dlls/kernel32/console.c
@@ -1156,7 +1156,7 @@ static enum read_console_input_return bare_console_fetch_input(HANDLE handle, in
                 break;
             case -1:
                 /* we haven't found the string into key-db, push full input string into server */
-                idxw = MultiByteToWideChar(CP_UNIXCP, 0, input, idx, inputw, sizeof(inputw) / sizeof(inputw[0]));
+                idxw = MultiByteToWideChar(CP_UNIXCP, 0, input, idx, inputw, ARRAY_SIZE(inputw));
 
                 /* we cannot translate yet... likely we need more chars (wait max 1/2s for next char) */
                 if (idxw == 0)
@@ -1831,7 +1831,7 @@ BOOL WINAPI SetConsoleInputExeNameW(LPCWSTR name)
     }
 
     RtlEnterCriticalSection(&CONSOLE_CritSect);
-    if (strlenW(name) < sizeof(input_exe)/sizeof(WCHAR)) strcpyW(input_exe, name);
+    if (strlenW(name) < ARRAY_SIZE(input_exe)) strcpyW(input_exe, name);
     RtlLeaveCriticalSection(&CONSOLE_CritSect);
 
     return TRUE;
diff --git a/dlls/kernel32/file.c b/dlls/kernel32/file.c
index 1e5b9fe..0c30fb7 100644
--- a/dlls/kernel32/file.c
+++ b/dlls/kernel32/file.c
@@ -1513,7 +1513,7 @@ HANDLE WINAPI CreateFileW( LPCWSTR filename, DWORD access, DWORD sharing,
         static const WCHAR conW[] = {'C','O','N'};
 
         if (LOWORD(dosdev) == sizeof(conW) &&
-            !memicmpW( filename + HIWORD(dosdev)/sizeof(WCHAR), conW, sizeof(conW)/sizeof(WCHAR)))
+            !memicmpW( filename + HIWORD(dosdev)/sizeof(WCHAR), conW, ARRAY_SIZE( conW )))
         {
             switch (access & (GENERIC_READ|GENERIC_WRITE))
             {
diff --git a/dlls/kernel32/lcformat.c b/dlls/kernel32/lcformat.c
index aeb48c6..b1dd32d 100644
--- a/dlls/kernel32/lcformat.c
+++ b/dlls/kernel32/lcformat.c
@@ -104,7 +104,7 @@ static DWORD NLS_GetLocaleNumber(LCID lcid, DWORD dwFlags)
   DWORD dwVal = 0;
 
   szBuff[0] = '\0';
-  GetLocaleInfoW(lcid, dwFlags, szBuff, sizeof(szBuff) / sizeof(WCHAR));
+  GetLocaleInfoW(lcid, dwFlags, szBuff, ARRAY_SIZE(szBuff));
 
   if (szBuff[0] && szBuff[1] == ';' && szBuff[2] != '0')
     dwVal = (szBuff[0] - '0') * 10 + (szBuff[2] - '0');
@@ -129,7 +129,7 @@ static WCHAR* NLS_GetLocaleString(LCID lcid, DWORD dwFlags)
   DWORD dwLen;
 
   szBuff[0] = '\0';
-  GetLocaleInfoW(lcid, dwFlags, szBuff, sizeof(szBuff) / sizeof(WCHAR));
+  GetLocaleInfoW(lcid, dwFlags, szBuff, ARRAY_SIZE(szBuff));
   dwLen = strlenW(szBuff) + 1;
   str = HeapAlloc(GetProcessHeap(), 0, dwLen * sizeof(WCHAR));
   if (str)
@@ -258,7 +258,7 @@ static const NLS_FORMAT_NODE *NLS_GetFormats(LCID lcid, DWORD dwFlags)
     GET_LOCALE_STRING(new_node->cyfmt.lpCurrencySymbol, LOCALE_SCURRENCY);
 
     /* Date/Time Format info, negative character, etc */
-    for (i = 0; i < sizeof(NLS_LocaleIndices)/sizeof(NLS_LocaleIndices[0]); i++)
+    for (i = 0; i < ARRAY_SIZE(NLS_LocaleIndices); i++)
     {
       GET_LOCALE_STRING(new_node->lppszStrings[i], NLS_LocaleIndices[i]);
     }
@@ -302,7 +302,7 @@ static const NLS_FORMAT_NODE *NLS_GetFormats(LCID lcid, DWORD dwFlags)
       /* We raced and lost: The node was already added by another thread.
        * node points to the currently cached node, so free new_node.
        */
-      for (i = 0; i < sizeof(NLS_LocaleIndices)/sizeof(NLS_LocaleIndices[0]); i++)
+      for (i = 0; i < ARRAY_SIZE(NLS_LocaleIndices); i++)
         HeapFree(GetProcessHeap(), 0, new_node->lppszStrings[i]);
       HeapFree(GetProcessHeap(), 0, new_node->fmt.lpDecimalSep);
       HeapFree(GetProcessHeap(), 0, new_node->fmt.lpThousandSep);
@@ -677,7 +677,7 @@ static INT NLS_GetDateTimeFormatW(LCID lcid, DWORD dwFlags,
       {
         static const WCHAR fmtW[] = {'%','.','*','d',0};
         /* We have a numeric value to add */
-        snprintfW(buff, sizeof(buff)/sizeof(WCHAR), fmtW, count, dwVal);
+        snprintfW(buff, ARRAY_SIZE(buff), fmtW, count, dwVal);
       }
 
       dwLen = szAdd ? strlenW(szAdd) : 0;
@@ -773,10 +773,10 @@ static INT NLS_GetDateTimeFormatA(LCID lcid, DWORD dwFlags,
   }
 
   if (lpFormat)
-    MultiByteToWideChar(cp, 0, lpFormat, -1, szFormat, sizeof(szFormat)/sizeof(WCHAR));
+    MultiByteToWideChar(cp, 0, lpFormat, -1, szFormat, ARRAY_SIZE(szFormat));
 
-  if (cchOut > (int)(sizeof(szOut)/sizeof(WCHAR)))
-    cchOut = sizeof(szOut)/sizeof(WCHAR);
+  if (cchOut > (int) ARRAY_SIZE(szOut))
+    cchOut = ARRAY_SIZE(szOut);
 
   szOut[0] = '\0';
 
@@ -1063,21 +1063,21 @@ INT WINAPI GetNumberFormatA(LCID lcid, DWORD dwFlags,
     pfmt = &fmt;
     if (lpFormat->lpDecimalSep)
     {
-      MultiByteToWideChar(cp, 0, lpFormat->lpDecimalSep, -1, szDec, sizeof(szDec)/sizeof(WCHAR));
+      MultiByteToWideChar(cp, 0, lpFormat->lpDecimalSep, -1, szDec, ARRAY_SIZE(szDec));
       fmt.lpDecimalSep = szDec;
     }
     if (lpFormat->lpThousandSep)
     {
-      MultiByteToWideChar(cp, 0, lpFormat->lpThousandSep, -1, szGrp, sizeof(szGrp)/sizeof(WCHAR));
+      MultiByteToWideChar(cp, 0, lpFormat->lpThousandSep, -1, szGrp, ARRAY_SIZE(szGrp));
       fmt.lpThousandSep = szGrp;
     }
   }
 
   if (lpszValue)
-    MultiByteToWideChar(cp, 0, lpszValue, -1, szIn, sizeof(szIn)/sizeof(WCHAR));
+    MultiByteToWideChar(cp, 0, lpszValue, -1, szIn, ARRAY_SIZE(szIn));
 
-  if (cchOut > (int)(sizeof(szOut)/sizeof(WCHAR)))
-    cchOut = sizeof(szOut)/sizeof(WCHAR);
+  if (cchOut > (int) ARRAY_SIZE(szOut))
+    cchOut = ARRAY_SIZE(szOut);
 
   szOut[0] = '\0';
 
@@ -1112,7 +1112,7 @@ INT WINAPI GetNumberFormatW(LCID lcid, DWORD dwFlags,
                             LPCWSTR lpszValue,  const NUMBERFMTW *lpFormat,
                             LPWSTR lpNumberStr, int cchOut)
 {
-  WCHAR szBuff[128], *szOut = szBuff + sizeof(szBuff) / sizeof(WCHAR) - 1;
+  WCHAR szBuff[128], *szOut = szBuff + ARRAY_SIZE(szBuff) - 1;
   WCHAR szNegBuff[8];
   const WCHAR *lpszNeg = NULL, *lpszNegStart, *szSrc;
   DWORD dwState = 0, dwDecimals = 0, dwGroupCount = 0, dwCurrentGroupCount = 0;
@@ -1140,7 +1140,7 @@ INT WINAPI GetNumberFormatW(LCID lcid, DWORD dwFlags,
   else
   {
     GetLocaleInfoW(lcid, LOCALE_SNEGATIVESIGN|(dwFlags & LOCALE_NOUSEROVERRIDE),
-                   szNegBuff, sizeof(szNegBuff)/sizeof(WCHAR));
+                   szNegBuff, ARRAY_SIZE(szNegBuff));
     lpszNegStart = lpszNeg = szNegBuff;
   }
   lpszNeg = lpszNeg + strlenW(lpszNeg) - 1;
@@ -1427,26 +1427,26 @@ INT WINAPI GetCurrencyFormatA(LCID lcid, DWORD dwFlags,
     pfmt = &fmt;
     if (lpFormat->lpDecimalSep)
     {
-      MultiByteToWideChar(cp, 0, lpFormat->lpDecimalSep, -1, szDec, sizeof(szDec)/sizeof(WCHAR));
+      MultiByteToWideChar(cp, 0, lpFormat->lpDecimalSep, -1, szDec, ARRAY_SIZE(szDec));
       fmt.lpDecimalSep = szDec;
     }
     if (lpFormat->lpThousandSep)
     {
-      MultiByteToWideChar(cp, 0, lpFormat->lpThousandSep, -1, szGrp, sizeof(szGrp)/sizeof(WCHAR));
+      MultiByteToWideChar(cp, 0, lpFormat->lpThousandSep, -1, szGrp, ARRAY_SIZE(szGrp));
       fmt.lpThousandSep = szGrp;
     }
     if (lpFormat->lpCurrencySymbol)
     {
-      MultiByteToWideChar(cp, 0, lpFormat->lpCurrencySymbol, -1, szCy, sizeof(szCy)/sizeof(WCHAR));
+      MultiByteToWideChar(cp, 0, lpFormat->lpCurrencySymbol, -1, szCy, ARRAY_SIZE(szCy));
       fmt.lpCurrencySymbol = szCy;
     }
   }
 
   if (lpszValue)
-    MultiByteToWideChar(cp, 0, lpszValue, -1, szIn, sizeof(szIn)/sizeof(WCHAR));
+    MultiByteToWideChar(cp, 0, lpszValue, -1, szIn, ARRAY_SIZE(szIn));
 
-  if (cchOut > (int)(sizeof(szOut)/sizeof(WCHAR)))
-    cchOut = sizeof(szOut)/sizeof(WCHAR);
+  if (cchOut > (int) ARRAY_SIZE(szOut))
+    cchOut = ARRAY_SIZE(szOut);
 
   szOut[0] = '\0';
 
@@ -1502,7 +1502,7 @@ INT WINAPI GetCurrencyFormatW(LCID lcid, DWORD dwFlags,
     CF_CY_LEFT|CF_CY_SPACE,  /* $ 1.1 */
     CF_CY_RIGHT|CF_CY_SPACE, /* 1.1 $ */
   };
-  WCHAR szBuff[128], *szOut = szBuff + sizeof(szBuff) / sizeof(WCHAR) - 1;
+  WCHAR szBuff[128], *szOut = szBuff + ARRAY_SIZE(szBuff) - 1;
   WCHAR szNegBuff[8];
   const WCHAR *lpszNeg = NULL, *lpszNegStart, *szSrc, *lpszCy, *lpszCyStart;
   DWORD dwState = 0, dwDecimals = 0, dwGroupCount = 0, dwCurrentGroupCount = 0, dwFmt;
@@ -1533,7 +1533,7 @@ INT WINAPI GetCurrencyFormatW(LCID lcid, DWORD dwFlags,
   else
   {
     GetLocaleInfoW(lcid, LOCALE_SNEGATIVESIGN|(dwFlags & LOCALE_NOUSEROVERRIDE),
-                   szNegBuff, sizeof(szNegBuff)/sizeof(WCHAR));
+                   szNegBuff, ARRAY_SIZE(szNegBuff));
     lpszNegStart = lpszNeg = szNegBuff;
   }
   dwFlags &= (LOCALE_NOUSEROVERRIDE|LOCALE_USE_CP_ACP);
@@ -1841,9 +1841,9 @@ static BOOL NLS_EnumDateFormats(const struct enumdateformats_context *ctxt)
 
     lctype |= ctxt->flags & LOCALE_USE_CP_ACP;
     if (ctxt->unicode)
-        ret = GetLocaleInfoW(ctxt->lcid, lctype, bufW, sizeof(bufW)/sizeof(bufW[0]));
+        ret = GetLocaleInfoW(ctxt->lcid, lctype, bufW, ARRAY_SIZE(bufW));
     else
-        ret = GetLocaleInfoA(ctxt->lcid, lctype, bufA, sizeof(bufA)/sizeof(bufA[0]));
+        ret = GetLocaleInfoA(ctxt->lcid, lctype, bufA, ARRAY_SIZE(bufA));
 
     if (ret)
     {
@@ -1994,9 +1994,9 @@ static BOOL NLS_EnumTimeFormats(struct enumtimeformats_context *ctxt)
 
     lctype |= ctxt->flags & LOCALE_USE_CP_ACP;
     if (ctxt->unicode)
-        ret = GetLocaleInfoW(ctxt->lcid, lctype, bufW, sizeof(bufW)/sizeof(bufW[0]));
+        ret = GetLocaleInfoW(ctxt->lcid, lctype, bufW, ARRAY_SIZE(bufW));
     else
-        ret = GetLocaleInfoA(ctxt->lcid, lctype, bufA, sizeof(bufA)/sizeof(bufA[0]));
+        ret = GetLocaleInfoA(ctxt->lcid, lctype, bufA, ARRAY_SIZE(bufA));
 
     if (ret)
     {
diff --git a/dlls/kernel32/locale.c b/dlls/kernel32/locale.c
index 2e0cf83..0f37027 100644
--- a/dlls/kernel32/locale.c
+++ b/dlls/kernel32/locale.c
@@ -355,8 +355,7 @@ static UINT find_charset( const WCHAR *name )
         if (isalnum((unsigned char)name[i])) charset_name[j++] = name[i];
     charset_name[j] = 0;
 
-    entry = bsearch( charset_name, charset_names,
-                     sizeof(charset_names)/sizeof(charset_names[0]),
+    entry = bsearch( charset_name, charset_names, ARRAY_SIZE( charset_names ),
                      sizeof(charset_names[0]), charset_cmp );
     if (entry) return entry->codepage;
     return 0;
@@ -395,8 +394,7 @@ static BOOL CALLBACK find_locale_id_callback( HMODULE hModule, LPCWSTR type,
 
     /* first check exact name */
     if (data->win_name[0] &&
-        GetLocaleInfoW( lcid, LOCALE_SNAME | LOCALE_NOUSEROVERRIDE,
-                        buffer, sizeof(buffer)/sizeof(WCHAR) ))
+        GetLocaleInfoW( lcid, LOCALE_SNAME | LOCALE_NOUSEROVERRIDE, buffer, ARRAY_SIZE( buffer )))
     {
         if (!strcmpiW( data->win_name, buffer ))
         {
@@ -406,7 +404,7 @@ static BOOL CALLBACK find_locale_id_callback( HMODULE hModule, LPCWSTR type,
     }
 
     if (!GetLocaleInfoW( lcid, LOCALE_SISO639LANGNAME | LOCALE_NOUSEROVERRIDE,
-                         buffer, sizeof(buffer)/sizeof(WCHAR) ))
+                         buffer, ARRAY_SIZE( buffer )))
         return TRUE;
     if (strcmpiW( buffer, data->lang )) return TRUE;
     matches++;  /* language name matched */
@@ -414,7 +412,7 @@ static BOOL CALLBACK find_locale_id_callback( HMODULE hModule, LPCWSTR type,
     if (data->script)
     {
         if (GetLocaleInfoW( lcid, LOCALE_SSCRIPTS | LOCALE_NOUSEROVERRIDE,
-                            buffer, sizeof(buffer)/sizeof(WCHAR) ))
+                            buffer, ARRAY_SIZE( buffer )))
         {
             const WCHAR *p = buffer;
             unsigned int len = strlenW( data->script );
@@ -432,7 +430,7 @@ static BOOL CALLBACK find_locale_id_callback( HMODULE hModule, LPCWSTR type,
     if (data->country)
     {
         if (GetLocaleInfoW( lcid, LOCALE_SISO3166CTRYNAME|LOCALE_NOUSEROVERRIDE,
-                            buffer, sizeof(buffer)/sizeof(WCHAR) ))
+                            buffer, ARRAY_SIZE( buffer )))
         {
             if (strcmpiW( buffer, data->country )) goto done;
             matches++;  /* country name matched */
@@ -490,7 +488,7 @@ static void parse_locale_name( const WCHAR *str, struct locale_name *name )
     name->matches = 0;
     name->codepage = 0;
     name->win_name[0] = 0;
-    lstrcpynW( name->lang, str, sizeof(name->lang)/sizeof(WCHAR) );
+    lstrcpynW( name->lang, str, ARRAY_SIZE( name->lang ));
 
     if (!*name->lang)
     {
@@ -816,8 +814,7 @@ static BOOL locale_update_registry( HKEY hkey, const WCHAR *name, LCID lcid,
 
     for (i = 0; i < nb_values; i++)
     {
-        GetLocaleInfoW( lcid, values[i] | LOCALE_NOUSEROVERRIDE, bufferW,
-                        sizeof(bufferW)/sizeof(WCHAR) );
+        GetLocaleInfoW( lcid, values[i] | LOCALE_NOUSEROVERRIDE, bufferW, ARRAY_SIZE( bufferW ));
         SetLocaleInfoW( lcid, values[i], bufferW );
     }
     return TRUE;
@@ -905,19 +902,19 @@ void LOCALE_InitRegistry(void)
         return;  /* don't do anything if we can't create the registry key */
 
     locale_update_registry( hkey, localeW, lcid_LC_MESSAGES, lc_messages_values,
-                            sizeof(lc_messages_values)/sizeof(lc_messages_values[0]) );
+                            ARRAY_SIZE( lc_messages_values ));
     locale_update_registry( hkey, lc_monetaryW, lcid_LC_MONETARY, lc_monetary_values,
-                            sizeof(lc_monetary_values)/sizeof(lc_monetary_values[0]) );
+                            ARRAY_SIZE( lc_monetary_values ));
     locale_update_registry( hkey, lc_numericW, lcid_LC_NUMERIC, lc_numeric_values,
-                            sizeof(lc_numeric_values)/sizeof(lc_numeric_values[0]) );
+                            ARRAY_SIZE( lc_numeric_values ));
     locale_update_registry( hkey, lc_timeW, lcid_LC_TIME, lc_time_values,
-                            sizeof(lc_time_values)/sizeof(lc_time_values[0]) );
+                            ARRAY_SIZE( lc_time_values ));
     locale_update_registry( hkey, lc_measurementW, lcid_LC_MEASUREMENT, lc_measurement_values,
-                            sizeof(lc_measurement_values)/sizeof(lc_measurement_values[0]) );
+                            ARRAY_SIZE( lc_measurement_values ));
     locale_update_registry( hkey, lc_telephoneW, lcid_LC_TELEPHONE, lc_telephone_values,
-                            sizeof(lc_telephone_values)/sizeof(lc_telephone_values[0]) );
+                            ARRAY_SIZE( lc_telephone_values ));
     locale_update_registry( hkey, lc_paperW, lcid_LC_PAPER, lc_paper_values,
-                            sizeof(lc_paper_values)/sizeof(lc_paper_values[0]) );
+                            ARRAY_SIZE( lc_paper_values ));
 
     if (locale_update_registry( hkey, lc_ctypeW, lcid_LC_CTYPE, NULL, 0 ))
     {
@@ -943,10 +940,10 @@ void LOCALE_InitRegistry(void)
         nameW.Length = len * sizeof(WCHAR);
         if (!NtCreateKey( &nls_key, KEY_ALL_ACCESS, &attr, 0, NULL, 0, NULL ))
         {
-            for (i = 0; i < sizeof(update_cp_values)/sizeof(update_cp_values[0]); i++)
+            for (i = 0; i < ARRAY_SIZE( update_cp_values ); i++)
             {
                 count = GetLocaleInfoW( lcid, update_cp_values[i].value | LOCALE_NOUSEROVERRIDE,
-                                        bufferW, sizeof(bufferW)/sizeof(WCHAR) );
+                                        bufferW, ARRAY_SIZE( bufferW ));
                 RtlInitUnicodeString( &nameW, update_cp_values[i].name );
                 NtSetValueKey( nls_key, &nameW, 0, REG_SZ, bufferW, count * sizeof(WCHAR) );
             }
@@ -1112,7 +1109,7 @@ static UINT setup_unix_locales(void)
 
     if ((locale = get_locale( LC_CTYPE, "LC_CTYPE" )))
     {
-        strcpynAtoW( ctype_buff, locale, sizeof(ctype_buff)/sizeof(WCHAR) );
+        strcpynAtoW( ctype_buff, locale, ARRAY_SIZE( ctype_buff ));
         parse_locale_name( ctype_buff, &locale_name );
         lcid_LC_CTYPE = locale_name.lcid;
         unix_cp = locale_name.codepage;
@@ -1126,7 +1123,7 @@ static UINT setup_unix_locales(void)
 #define GET_UNIX_LOCALE(cat) do \
     if ((locale = get_locale( cat, #cat ))) \
     { \
-        strcpynAtoW( buffer, locale, sizeof(buffer)/sizeof(WCHAR) ); \
+        strcpynAtoW( buffer, locale, ARRAY_SIZE(buffer) ); \
         if (!strcmpW( buffer, ctype_buff )) lcid_##cat = lcid_LC_CTYPE; \
         else { \
             parse_locale_name( buffer, &locale_name );  \
@@ -1444,7 +1441,7 @@ INT WINAPI LCIDToLocaleName( LCID lcid, LPWSTR name, INT count, DWORD flags )
 static struct registry_value *get_locale_registry_value( DWORD lctype )
 {
     int i;
-    for (i=0; i < sizeof(registry_values)/sizeof(registry_values[0]); i++)
+    for (i = 0; i < ARRAY_SIZE( registry_values ); i++)
         if (registry_values[i].lctype == lctype)
             return &registry_values[i];
     return NULL;
@@ -1698,7 +1695,7 @@ INT WINAPI GetLocaleInfoW( LCID lcid, LCTYPE lctype, LPWSTR buffer, INT len )
             if (lcflags & LOCALE_RETURN_NUMBER)
             {
                 WCHAR tmp[16];
-                ret = get_registry_locale_info( value, tmp, sizeof(tmp)/sizeof(WCHAR) );
+                ret = get_registry_locale_info( value, tmp, ARRAY_SIZE( tmp ));
                 if (ret > 0)
                 {
                     WCHAR *end;
@@ -2219,7 +2216,7 @@ BOOL WINAPI GetCPInfoExW( UINT codepage, DWORD dwFlags, LPCPINFOEXW cpinfo )
             cpinfo->CodePage = table->info.codepage;
             cpinfo->UnicodeDefaultChar = table->info.def_unicode_char;
             MultiByteToWideChar( CP_ACP, 0, table->info.name, -1, cpinfo->CodePageName,
-                                 sizeof(cpinfo->CodePageName)/sizeof(WCHAR));
+                                 ARRAY_SIZE( cpinfo->CodePageName ));
             break;
         }
     }
@@ -2269,7 +2266,7 @@ BOOL WINAPI EnumSystemCodePagesW( CODEPAGE_ENUMPROCW lpfnCodePageEnum, DWORD fla
     for (;;)
     {
         if (!(table = wine_cp_enum_table( index++ ))) break;
-        p = buffer + sizeof(buffer)/sizeof(WCHAR);
+        p = buffer + ARRAY_SIZE( buffer );
         *--p = 0;
         page = table->info.codepage;
         do
@@ -2989,7 +2986,7 @@ static BOOL CALLBACK enum_locale_ex_proc( HMODULE module, LPCWSTR type,
     unsigned int flags;
 
     GetLocaleInfoW( MAKELCID( lang, SORT_DEFAULT ), LOCALE_SNAME | LOCALE_NOUSEROVERRIDE,
-                    buffer, sizeof(buffer) / sizeof(WCHAR) );
+                    buffer, ARRAY_SIZE( buffer ));
     if (!GetLocaleInfoW( MAKELCID( lang, SORT_DEFAULT ),
                          LOCALE_INEUTRAL | LOCALE_NOUSEROVERRIDE | LOCALE_RETURN_NUMBER,
                          (LPWSTR)&neutral, sizeof(neutral) / sizeof(WCHAR) ))
@@ -3254,7 +3251,7 @@ static INT compose_katakana( LPCWSTR src, INT srclen, LPWSTR dst )
     default:
     {
         int shift = *src - 0xff61;
-        if (shift < 0 || shift >= sizeof(katakana_map)/sizeof(katakana_map[0]) )
+        if (shift < 0 || shift >= ARRAY_SIZE( katakana_map ))
             return 0;
         else
             *dst = katakana_map[shift] | 0x3000;
@@ -3362,7 +3359,7 @@ static INT decompose_katakana( WCHAR c, LPWSTR dst, INT dstlen )
     INT len = 0, shift = c - 0x3099;
     BYTE k;
 
-    if (shift < 0 || shift >= sizeof(katakana_map)/sizeof(katakana_map[0]))
+    if (shift < 0 || shift >= ARRAY_SIZE( katakana_map ))
         return 0;
 
     k = katakana_map[shift];
@@ -4382,7 +4379,7 @@ static BOOL NLS_EnumSystemLanguageGroups(ENUMLANGUAGEGROUP_CALLBACKS *lpProcs)
             {
                 WCHAR szGrpName[48];
 
-                if (!NLS_GetLanguageGroupName( lgrpid, szGrpName, sizeof(szGrpName) / sizeof(WCHAR) ))
+                if (!NLS_GetLanguageGroupName( lgrpid, szGrpName, ARRAY_SIZE( szGrpName )))
                     szGrpName[0] = '\0';
 
                 if (lpProcs->procW)
@@ -4390,7 +4387,7 @@ static BOOL NLS_EnumSystemLanguageGroups(ENUMLANGUAGEGROUP_CALLBACKS *lpProcs)
                                                 lpProcs->lParam );
                 else
                 {
-                    char szNumberA[sizeof(szNumber)/sizeof(WCHAR)];
+                    char szNumberA[ARRAY_SIZE( szNumber )];
                     char szGrpNameA[48];
 
                     /* FIXME: MSDN doesn't say which code page the W->A translation uses,
@@ -4584,7 +4581,7 @@ static BOOL NLS_EnumLanguageGroupLocales(ENUMLANGUAGEGROUPLOCALE_CALLBACKS *lpPr
                     bContinue = lpProcs->procW( lgrpid, lcid, szNumber, lpProcs->lParam );
                 else
                 {
-                    char szNumberA[sizeof(szNumber)/sizeof(WCHAR)];
+                    char szNumberA[ARRAY_SIZE( szNumber )];
 
                     WideCharToMultiByte(CP_ACP, 0, szNumber, -1, szNumberA, sizeof(szNumberA), 0, 0);
 
@@ -5174,7 +5171,7 @@ static const struct geoinfo_t *get_geoinfo_dataptr(GEOID geoid)
     int min, max;
 
     min = 0;
-    max = sizeof(geoinfodata)/sizeof(struct geoinfo_t)-1;
+    max = ARRAY_SIZE(geoinfodata)-1;
 
     while (min <= max) {
         const struct geoinfo_t *ptr;
@@ -5324,7 +5321,7 @@ BOOL WINAPI EnumSystemGeoID(GEOCLASS geoclass, GEOID parent, GEO_ENUMPROC enumpr
         return FALSE;
     }
 
-    for (i = 0; i < sizeof(geoinfodata)/sizeof(struct geoinfo_t); i++) {
+    for (i = 0; i < ARRAY_SIZE(geoinfodata); i++) {
         const struct geoinfo_t *ptr = &geoinfodata[i];
 
         if (geoclass == GEOCLASS_NATION && (ptr->kind == LOCATION_REGION))
@@ -5682,8 +5679,7 @@ INT WINAPI IdnToNameprepUnicode(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, INT cch
             }
         }
 
-        norm_len = FoldStringW(MAP_FOLDCZONE, map_str, map_len,
-                norm_str, sizeof(norm_str)/sizeof(WCHAR)-1);
+        norm_len = FoldStringW(MAP_FOLDCZONE, map_str, map_len, norm_str, ARRAY_SIZE(norm_str)-1);
         if(map_str != buf)
             HeapFree(GetProcessHeap(), 0, map_str);
         if(!norm_len) {
diff --git a/dlls/kernel32/module.c b/dlls/kernel32/module.c
index 3ab70e8..1188298 100644
--- a/dlls/kernel32/module.c
+++ b/dlls/kernel32/module.c
@@ -1142,8 +1142,7 @@ static BOOL load_library_as_datafile( LPCWSTR name, HMODULE *hmod, DWORD flags )
 
     if (flags & LOAD_LIBRARY_AS_IMAGE_RESOURCE) protect |= SEC_IMAGE;
 
-    if (SearchPathW( NULL, name, dotDLL, sizeof(filenameW) / sizeof(filenameW[0]),
-                     filenameW, NULL ))
+    if (SearchPathW( NULL, name, dotDLL, ARRAY_SIZE( filenameW ), filenameW, NULL ))
     {
         hFile = CreateFileW( filenameW, GENERIC_READ, sharing, NULL, OPEN_EXISTING, 0, 0 );
     }
diff --git a/dlls/kernel32/path.c b/dlls/kernel32/path.c
index a389743..489f59e 100644
--- a/dlls/kernel32/path.c
+++ b/dlls/kernel32/path.c
@@ -893,7 +893,7 @@ static NTSTATUS find_actctx_dllpath(const WCHAR *libname, WCHAR **path)
     strcpyW( p, DIR_Windows );
     p += strlenW(p);
     memcpy( p, winsxsW, sizeof(winsxsW) );
-    p += sizeof(winsxsW) / sizeof(WCHAR);
+    p += ARRAY_SIZE( winsxsW );
     memcpy( p, info->lpAssemblyDirectoryName, info->ulAssemblyDirectoryNameLength );
     p += info->ulAssemblyDirectoryNameLength / sizeof(WCHAR);
     *p++ = '\\';
diff --git a/dlls/kernel32/process.c b/dlls/kernel32/process.c
index 4e6ba11..5aa245c 100644
--- a/dlls/kernel32/process.c
+++ b/dlls/kernel32/process.c
@@ -377,7 +377,7 @@ static void set_registry_variables( HANDLE hkey, ULONG type )
         }
         /* PATH is magic */
         if (env_name.Length == sizeof(pathW) &&
-            !memicmpW( env_name.Buffer, pathW, sizeof(pathW)/sizeof(WCHAR) ) &&
+            !memicmpW( env_name.Buffer, pathW, ARRAY_SIZE( pathW )) &&
             !RtlQueryEnvironmentVariable_U( NULL, &env_name, &tmp ))
         {
             RtlAppendUnicodeToString( &tmp, sep );
@@ -528,7 +528,7 @@ static void set_additional_environment(void)
     DWORD len;
 
     /* ComputerName */
-    len = sizeof(buf) / sizeof(WCHAR);
+    len = ARRAY_SIZE( buf );
     if (GetComputerNameW( buf, &len ))
         SetEnvironmentVariableW( computernameW, buf );
 
@@ -606,7 +606,7 @@ static void set_wow64_environment(void)
 
     /* set the PROCESSOR_ARCHITECTURE variable */
 
-    if (GetEnvironmentVariableW( arch6432W, arch, sizeof(arch)/sizeof(WCHAR) ))
+    if (GetEnvironmentVariableW( arch6432W, arch, ARRAY_SIZE( arch )))
     {
         if (is_win64)
         {
@@ -614,7 +614,7 @@ static void set_wow64_environment(void)
             SetEnvironmentVariableW( arch6432W, NULL );
         }
     }
-    else if (GetEnvironmentVariableW( archW, arch, sizeof(arch)/sizeof(WCHAR) ))
+    else if (GetEnvironmentVariableW( archW, arch, ARRAY_SIZE( arch )))
     {
         if (is_wow64)
         {
@@ -1002,7 +1002,7 @@ static void start_wineboot( HANDLE handles[2] )
         PROCESS_INFORMATION pi;
         void *redir;
         WCHAR app[MAX_PATH];
-        WCHAR cmdline[MAX_PATH + (sizeof(wineboot) + sizeof(args)) / sizeof(WCHAR)];
+        WCHAR cmdline[MAX_PATH + ARRAY_SIZE( wineboot ) + ARRAY_SIZE( args )];
 
         memset( &si, 0, sizeof(si) );
         si.cb = sizeof(si);
@@ -1011,7 +1011,7 @@ static void start_wineboot( HANDLE handles[2] )
         si.hStdOutput = 0;
         si.hStdError  = GetStdHandle( STD_ERROR_HANDLE );
 
-        GetSystemDirectoryW( app, MAX_PATH - sizeof(wineboot)/sizeof(WCHAR) );
+        GetSystemDirectoryW( app, MAX_PATH - ARRAY_SIZE( wineboot ));
         lstrcatW( app, wineboot );
 
         Wow64DisableWow64FsRedirection( &redir );
@@ -1291,7 +1291,7 @@ void CDECL __wine_kernel_init(void)
         }
         args[0] = (DWORD_PTR)main_exe_name;
         FormatMessageW( FORMAT_MESSAGE_FROM_SYSTEM | FORMAT_MESSAGE_ARGUMENT_ARRAY,
-                        NULL, error, 0, msgW, sizeof(msgW)/sizeof(WCHAR), (__ms_va_list *)args );
+                        NULL, error, 0, msgW, ARRAY_SIZE( msgW ), (__ms_va_list *)args );
         WideCharToMultiByte( CP_UNIXCP, 0, msgW, -1, msg, sizeof(msg), NULL, NULL );
         MESSAGE( "wine: %s", msg );
         ExitProcess( error );
@@ -1440,7 +1440,7 @@ static char **build_envp( const WCHAR *envW )
     for (p = env; *p; p += strlen(p) + 1)
         if (is_special_env_var( p )) length += 4; /* prefix it with "WINE" */
 
-    for (i = 0; i < sizeof(unix_vars)/sizeof(unix_vars[0]); i++)
+    for (i = 0; i < ARRAY_SIZE( unix_vars ); i++)
     {
         if (!(p = getenv(unix_vars[i]))) continue;
         length += strlen(unix_vars[i]) + strlen(p) + 2;
@@ -1453,7 +1453,7 @@ static char **build_envp( const WCHAR *envW )
         char *dst = (char *)(envp + count);
 
         /* some variables must not be modified, so we get them directly from the unix env */
-        for (i = 0; i < sizeof(unix_vars)/sizeof(unix_vars[0]); i++)
+        for (i = 0; i < ARRAY_SIZE( unix_vars ); i++)
         {
             if (!(p = getenv(unix_vars[i]))) continue;
             *envptr++ = strcpy( dst, unix_vars[i] );
@@ -2048,7 +2048,7 @@ static BOOL create_process( HANDLE hFile, LPCWSTR filename, LPWSTR cmd_line, LPW
     while (*env_end)
     {
         static const WCHAR WINEDEBUG[] = {'W','I','N','E','D','E','B','U','G','=',0};
-        if (!winedebug && !strncmpW( env_end, WINEDEBUG, sizeof(WINEDEBUG)/sizeof(WCHAR) - 1 ))
+        if (!winedebug && !strncmpW( env_end, WINEDEBUG, ARRAY_SIZE( WINEDEBUG ) - 1 ))
         {
             DWORD len = WideCharToMultiByte( CP_UNIXCP, 0, env_end, -1, NULL, 0, NULL, NULL );
             if ((winedebug = HeapAlloc( GetProcessHeap(), 0, len )))
@@ -2219,7 +2219,7 @@ static BOOL create_cmd_process( LPCWSTR filename, LPWSTR cmd_line, LPVOID env, L
     WCHAR *newcmdline;
     BOOL ret;
 
-    if (!GetEnvironmentVariableW( comspecW, comspec, sizeof(comspec)/sizeof(WCHAR) ))
+    if (!GetEnvironmentVariableW( comspecW, comspec, ARRAY_SIZE( comspec )))
         return FALSE;
     if (!(newcmdline = HeapAlloc( GetProcessHeap(), 0,
                                   (strlenW(comspec) + 7 + strlenW(cmd_line) + 2) * sizeof(WCHAR))))
@@ -2340,7 +2340,7 @@ static BOOL create_process_impl( LPCWSTR app_name, LPWSTR cmd_line, LPSECURITY_A
 
     TRACE("app %s cmdline %s\n", debugstr_w(app_name), debugstr_w(cmd_line) );
 
-    if (!(tidy_cmdline = get_file_name( app_name, cmd_line, name, sizeof(name)/sizeof(WCHAR),
+    if (!(tidy_cmdline = get_file_name( app_name, cmd_line, name, ARRAY_SIZE( name ),
                                         &hFile, &binary_info )))
         return FALSE;
     if (hFile == INVALID_HANDLE_VALUE) goto done;
@@ -3624,7 +3624,7 @@ BOOL WINAPI QueryFullProcessImageNameW(HANDLE hProcess, DWORD dwFlags, LPWSTR lp
         drive[0] = result->Buffer[0];
         drive[1] = ':';
         drive[2] = 0;
-        if (!QueryDosDeviceW(drive, device, sizeof(device)/sizeof(*device)))
+        if (!QueryDosDeviceW(drive, device, ARRAY_SIZE(device)))
         {
             status = STATUS_NO_SUCH_DEVICE;
             goto cleanup;
diff --git a/dlls/kernel32/profile.c b/dlls/kernel32/profile.c
index 0974aaf..65a8f28 100644
--- a/dlls/kernel32/profile.c
+++ b/dlls/kernel32/profile.c
@@ -772,7 +772,7 @@ static BOOL PROFILE_Open( LPCWSTR filename, BOOL write_access )
     else
     {
         LPWSTR dummy;
-        GetFullPathNameW(filename, sizeof(buffer)/sizeof(buffer[0]), buffer, &dummy);
+        GetFullPathNameW(filename, ARRAY_SIZE(buffer), buffer, &dummy);
     }
         
     TRACE("path: %s\n", debugstr_w(buffer));
@@ -1238,9 +1238,8 @@ UINT WINAPI GetPrivateProfileIntW( LPCWSTR section, LPCWSTR entry,
     UNICODE_STRING bufferW;
     ULONG result;
 
-    if (GetPrivateProfileStringW( section, entry, emptystringW,
-                                   buffer, sizeof(buffer)/sizeof(WCHAR),
-                                   filename ) == 0)
+    if (GetPrivateProfileStringW( section, entry, emptystringW, buffer, ARRAY_SIZE( buffer ),
+                                  filename ) == 0)
         return def_val;
 
     /* FIXME: if entry can be found but it's empty, then Win16 is
diff --git a/dlls/kernel32/sync.c b/dlls/kernel32/sync.c
index 343998e..6c7249c 100644
--- a/dlls/kernel32/sync.c
+++ b/dlls/kernel32/sync.c
@@ -1594,7 +1594,7 @@ BOOL WINAPI WaitNamedPipeW (LPCWSTR name, DWORD nTimeOut)
 
     if (nt_name.Length >= MAX_PATH * sizeof(WCHAR) ||
         nt_name.Length < sizeof(leadin) ||
-        strncmpiW( nt_name.Buffer, leadin, sizeof(leadin)/sizeof(WCHAR)) != 0)
+        strncmpiW( nt_name.Buffer, leadin, ARRAY_SIZE( leadin )) != 0)
     {
         RtlFreeUnicodeString( &nt_name );
         SetLastError( ERROR_PATH_NOT_FOUND );
@@ -1630,8 +1630,7 @@ BOOL WINAPI WaitNamedPipeW (LPCWSTR name, DWORD nTimeOut)
     else
         pipe_wait->Timeout.QuadPart = (ULONGLONG)nTimeOut * -10000;
     pipe_wait->NameLength = nt_name.Length - sizeof(leadin);
-    memcpy(pipe_wait->Name, nt_name.Buffer + sizeof(leadin)/sizeof(WCHAR),
-           pipe_wait->NameLength);
+    memcpy( pipe_wait->Name, nt_name.Buffer + ARRAY_SIZE( leadin ), pipe_wait->NameLength );
     RtlFreeUnicodeString( &nt_name );
 
     status = NtFsControlFile( pipe_dev, NULL, NULL, NULL, &iosb, FSCTL_PIPE_WAIT,
@@ -2084,8 +2083,7 @@ BOOL WINAPI CreatePipe( PHANDLE hReadPipe, PHANDLE hWritePipe,
          '\\','W','i','n','3','2','.','P','i','p','e','s','.','%','0','8','l',
          'u','.','%','0','8','u','\0' };
 
-        snprintfW(name, sizeof(name) / sizeof(name[0]), nameFmt,
-                  GetCurrentProcessId(), ++index);
+        snprintfW(name, ARRAY_SIZE(name), nameFmt, GetCurrentProcessId(), ++index);
         RtlInitUnicodeString(&nt_name, name);
         status = NtCreateNamedPipeFile(&hr, GENERIC_READ | SYNCHRONIZE, &attr, &iosb,
                                        FILE_SHARE_WRITE, FILE_OVERWRITE_IF,
diff --git a/dlls/kernel32/term.c b/dlls/kernel32/term.c
index 171476a..b8877d4 100644
--- a/dlls/kernel32/term.c
+++ b/dlls/kernel32/term.c
@@ -373,7 +373,7 @@ static BOOL TERM_BuildKeyDB(void)
     struct dbkey_descr descr;
     char tmp[64];
 
-    for (i = 0; i < sizeof(TERM_dbkey_init) / sizeof(TERM_dbkey_init[0]); i++)
+    for (i = 0; i < ARRAY_SIZE(TERM_dbkey_init); i++)
     {
         if (!TERM_AddKeyDescr(tigetstr((char *)TERM_dbkey_init[i].string_normal), &TERM_dbkey_init[i].descr))
             return FALSE;
diff --git a/dlls/kernel32/volume.c b/dlls/kernel32/volume.c
index 3a4edf8..1208436 100644
--- a/dlls/kernel32/volume.c
+++ b/dlls/kernel32/volume.c
@@ -420,7 +420,7 @@ static BOOL UDF_Find_PVD( HANDLE handle, BYTE pvd[] )
     DWORD offset;
     INT locations[] = { 256, -1, -257, 512 };
 
-    for(i=0; i<sizeof(locations)/sizeof(locations[0]); i++)
+    for(i=0; i<ARRAY_SIZE(locations); i++)
     {
         if (!VOLUME_ReadCDBlock(handle, pvd, locations[i]*BLOCK_SIZE))
             return FALSE;
@@ -982,7 +982,7 @@ BOOL WINAPI GetVolumeNameForVolumeMountPointA( LPCSTR path, LPSTR volume, DWORD
 {
     BOOL ret;
     WCHAR volumeW[50], *pathW = NULL;
-    DWORD len = min( sizeof(volumeW) / sizeof(WCHAR), size );
+    DWORD len = min(ARRAY_SIZE(volumeW), size );
 
     TRACE("(%s, %p, %x)\n", debugstr_a(path), volume, size);
 
@@ -1105,7 +1105,7 @@ BOOL WINAPI GetVolumeNameForVolumeMountPointW( LPCWSTR path, LPWSTR volume, DWOR
             debugstr_wn((WCHAR*)((char *)output + o1->DeviceNameOffset),
                             o1->DeviceNameLength/sizeof(WCHAR)));
 
-        if (!strncmpW( p, volumeW, sizeof(volumeW)/sizeof(WCHAR) ))
+        if (!strncmpW( p, volumeW, ARRAY_SIZE( volumeW )))
         {
             /* is there space in the return variable ?? */
             if ((o1->SymbolicLinkNameLength/sizeof(WCHAR))+2 > size)
@@ -1763,7 +1763,7 @@ BOOL WINAPI GetVolumePathNameW(LPCWSTR filename, LPWSTR volumepathname, DWORD bu
                 goto cleanup;
             }
         }
-        else if (GetCurrentDirectoryW( sizeof(cwdW)/sizeof(cwdW[0]), cwdW ))
+        else if (GetCurrentDirectoryW(ARRAY_SIZE(cwdW), cwdW ))
         {
             /* if the path is completely bogus then revert to the drive of the working directory */
             fallbackpathW[0] = cwdW[0];
@@ -1942,12 +1942,12 @@ BOOL WINAPI GetVolumePathNamesForVolumeNameW(LPCWSTR volumename, LPWSTR volumepa
             linkname = (const WCHAR *)((const char *)link + link->MountPoints[j].SymbolicLinkNameOffset);
 
             if (link->MountPoints[j].SymbolicLinkNameLength == sizeof(dosdevicesW) + 2 * sizeof(WCHAR) &&
-                !memicmpW( linkname, dosdevicesW, sizeof(dosdevicesW) / sizeof(WCHAR) ))
+                !memicmpW( linkname, dosdevicesW, ARRAY_SIZE( dosdevicesW )))
             {
                 len += 4;
                 if (volumepathname && len < buflen)
                 {
-                    path[0] = linkname[sizeof(dosdevicesW) / sizeof(WCHAR)];
+                    path[0] = linkname[ARRAY_SIZE( dosdevicesW )];
                     path[1] = ':';
                     path[2] = '\\';
                     path[3] = 0;
-- 
1.9.1

